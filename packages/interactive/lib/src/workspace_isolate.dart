import 'dart:io';
import 'dart:isolate';

import 'package:collection/collection.dart';
import 'package:interactive/src/vm_service_wrapper.dart';
import 'package:interactive/src/workspace_file_tree.dart';
import 'package:logging/logging.dart';
import 'package:vm_service/vm_service.dart' as vm_service;

class WorkspaceIsolate {
  final VmServiceWrapper vm;
  final Isolate isolate;
  final String isolateId;

  WorkspaceIsolate._({
    required this.vm,
    required this.isolate,
    required this.isolateId,
  });

  static Future<WorkspaceIsolate> create(
      VmServiceWrapper vm, WorkspaceFileTree workspaceFileTree) async {
    print("Creating workspace isolate");
    final isolateIdsBefore = await vm.getIsolateIds();

    // Run pub get so that the package_config.json is generated and packages
    // are resolved correctly in the interpreter
    print("Running pub get");
    await _runPubGet(workingDirectory: workspaceFileTree.directory);

    print("Pub get finished");
    final packageConfigFile = File(workspaceFileTree.pathPackageConfig);
    assert(
      packageConfigFile.existsSync(),
      'package_config.json does not exist at ${packageConfigFile.parent.path}',
    );

    print("Spawning isolate");

    final isolate = await _spawnUriWithErrorHandling(
      Uri.file(workspaceFileTree.pathAutoGeneratedDart),
      packageConfigUri: Uri.file(packageConfigFile.path),
    );

    print("isolate spawned");

    final isolateIdsAfter = await vm.getIsolateIds();
    final isolateId = isolateIdsAfter.difference(isolateIdsBefore).single;

    return WorkspaceIsolate._(vm: vm, isolate: isolate, isolateId: isolateId);
  }

  Future<vm_service.Isolate> get isolateInfo =>
      vm.vmService.getIsolate(isolateId);

  void dispose() {
    isolate.kill(priority: Isolate.immediate);
  }
}

extension on VmServiceWrapper {
  Future<Set<String>> getIsolateIds() async => (await vmService.getVM())
      .isolates!
      .map((e) => e.id)
      .whereNotNull()
      .toSet();
}

// ref: [Isolate.run]
Future<Isolate> _spawnUriWithErrorHandling(
  Uri uri, {
  required Uri packageConfigUri,
}) async {
  final log = Logger('SpawnUriWithErrorHandling');

  late final RawReceivePort errorPort, exitPort;
  errorPort = RawReceivePort()
    ..handler = (Object? message) {
      log.warning('Isolate error: $message');
    };
  exitPort = RawReceivePort()
    ..handler = (Object? message) {
      log.info('Isolate exited (message: $message)');

      // otherwise see it running forever even after everything finished
      errorPort.close();
      exitPort.close();
    };

  return await Isolate.spawnUri(
    uri,
    const [],
    null,
    onError: errorPort.sendPort,
    onExit: exitPort.sendPort,
    packageConfig: packageConfigUri,
  );
}

Future<void> _runPubGet({required String workingDirectory}) async {
  final process = await Process.start(
    '/bin/sh',
    ['-c', 'dart pub get'],
    workingDirectory: workingDirectory,
    runInShell: true,
  );

  final code = await process.exitCode;

  if (code != 0) {
    throw Exception(
        "pub get at '$workingDirectory' failed with exit code $code");
  }
}
